import AutoGeneratedPlan from "../models/autoGeneratedPlan.model.js";
import SessionLog from "../models/sessionLog.model.js";

async function analyzePerformance(userId, lastNWeeks = 2) {
	const weeksAgo = new Date();
	weeksAgo.setDate(weeksAgo.getDate() - lastNWeeks * 7);
	const dateThreshold = formatDateString(weeksAgo);

	const logs = await SessionLog.find({
		userId,
		date: { $gte: dateThreshold },
	})
		.populate("entries.exerciseId")
		.lean();

	const performanceByExercise = {};

	for (const log of logs) {
		for (const entry of log.entries) {
			if (!entry.exerciseId) continue;

			const exerciseId = entry.exerciseId._id.toString();
			if (!performanceByExercise[exerciseId]) {
				performanceByExercise[exerciseId] = {
					exerciseId: entry.exerciseId,
					sessions: [],
					avgRPE: 0,
					completionRate: 0,
					progressionReady: false,
				};
			}

			performanceByExercise[exerciseId].sessions.push({
				date: log.date,
				status: entry.status,
				actual: entry.actual,
				rpe: entry.rpe,
				notes: entry.notes,
			});
		}
	}

	// Calculate metrics
	for (const exerciseId in performanceByExercise) {
		const data = performanceByExercise[exerciseId];
		const sessions = data.sessions;

		// Calculate average RPE
		const rpeValues = sessions.filter((s) => s.rpe).map((s) => s.rpe);
		data.avgRPE =
			rpeValues.length > 0
				? rpeValues.reduce((a, b) => a + b, 0) / rpeValues.length
				: 0;

		// Calculate completion rate
		const doneCount = sessions.filter((s) => s.status === "done").length;
		data.completionRate = (doneCount / sessions.length) * 100;

		// Check if ready for progression
		const lastTwo = sessions.slice(-2);
		const allDone = lastTwo.every((s) => s.status === "done");
		const lowRPE = lastTwo.every((s) => !s.rpe || s.rpe < 8);
		data.progressionReady = allDone && lowRPE && sessions.length >= 2;

		// Check for plateau
		const lastThree = sessions.slice(-3);
		const hasDifficulty = lastThree.some((s) => s.status === "difficult");
		const highRPE = lastThree.some((s) => s.rpe && s.rpe >= 9);
		data.plateau = hasDifficulty || highRPE;
	}

	return performanceByExercise;
}

async function suggestAdjustments(userId, autoGeneratedPlanId) {
	const plan = await AutoGeneratedPlan.findOne({
		_id: autoGeneratedPlanId,
		userId,
	});
	if (!plan) {
		throw new Error("Plan not found");
	}

	const performance = await analyzePerformance(userId, 2);
	const suggestions = [];

	for (const day of plan.weeklyStructure) {
		for (const exercise of day.exercises) {
			const exerciseId = exercise.exerciseId.toString();
			const perf = performance[exerciseId];

			if (!perf) continue;

			if (perf.progressionReady) {
				// Suggest progression
				const current = exercise.planned;
				let suggestion = {};

				if (exercise.progression_rule.method === "reps_then_load") {
					if (current.reps < 15) {
						suggestion = {
							...current,
							reps: current.reps + 1,
						};
					} else if (current.load_kg) {
						suggestion = {
							...current,
							reps: 10,
							load_kg: Math.round(current.load_kg * 1.05 * 2) / 2, // 5% increase, rounded to 0.5kg
						};
					}
				} else if (exercise.progression_rule.method === "load") {
					if (current.load_kg) {
						suggestion = {
							...current,
							load_kg: Math.round(current.load_kg * 1.025 * 2) / 2, // 2.5% increase
						};
					}
				} else if (exercise.progression_rule.method === "reps") {
					suggestion = {
						...current,
						reps: current.reps + 1,
					};
				}

				if (Object.keys(suggestion).length > 0) {
					suggestions.push({
						dayNumber: day.dayNumber,
						exerciseId: exercise.exerciseId,
						type: "progression",
						currentPlanned: current,
						suggestedPlanned: suggestion,
						reason: `Completed successfully for 2+ sessions with RPE < 8`,
					});
				}
			} else if (perf.plateau) {
				// Suggest deload or modification
				const current = exercise.planned;
				const deload = {
					...current,
					sets: Math.max(2, current.sets - 1),
					load_kg: current.load_kg ? current.load_kg * 0.9 : null,
				};

				suggestions.push({
					dayNumber: day.dayNumber,
					exerciseId: exercise.exerciseId,
					type: "deload",
					currentPlanned: current,
					suggestedPlanned: deload,
					reason: `Difficulty or high RPE detected, suggest deload`,
				});
			}
		}
	}

	return suggestions;
}

async function autoAdjustPlan(planId, userId) {
	const suggestions = await suggestAdjustments(userId, planId);
	const plan = await AutoGeneratedPlan.findOne({ _id: planId, userId });

	if (!plan) {
		throw new Error("Plan not found");
	}

	const adjustments = [];

	for (const suggestion of suggestions) {
		// Find the exercise in the plan
		const day = plan.weeklyStructure.find(
			(d) => d.dayNumber === suggestion.dayNumber
		);
		if (!day) continue;

		const exercise = day.exercises.find(
			(e) => e.exerciseId.toString() === suggestion.exerciseId.toString()
		);
		if (!exercise) continue;

		// Apply the suggestion
		exercise.planned = suggestion.suggestedPlanned;

		adjustments.push({
			exerciseId: suggestion.exerciseId,
			change: `${suggestion.type}: ${JSON.stringify(suggestion.suggestedPlanned)}`,
			reason: suggestion.reason,
		});
	}

	if (adjustments.length > 0) {
		plan.progressionHistory.push({
			date: formatDateString(new Date()),
			adjustments,
		});
		plan.lastModified = new Date();
		await plan.save();
	}

	return { plan, appliedAdjustments: adjustments };
}

async function handlePlateau(exerciseId, performanceData) {
	// Strategies for stalled progress
	const strategies = [
		{
			name: "deload",
			description: "Reduce volume by 10-20%",
			apply: (planned) => ({
				...planned,
				sets: Math.max(2, planned.sets - 1),
				load_kg: planned.load_kg ? planned.load_kg * 0.85 : null,
			}),
		},
		{
			name: "reduce_reps_increase_load",
			description: "Lower rep range, increase weight",
			apply: (planned) => ({
				...planned,
				reps: Math.max(3, planned.reps - 3),
				load_kg: planned.load_kg ? planned.load_kg * 1.1 : null,
			}),
		},
		{
			name: "increase_rest",
			description: "Add more rest between sets",
			apply: (planned) => ({
				...planned,
				rest_seconds: planned.rest_seconds + 30,
			}),
		},
	];

	// Return first strategy for now (can be made smarter)
	return strategies[0];
}

async function deloadIfNeeded(plan, fatigueIndicators) {
	// Check if deload is needed based on fatigue indicators
	// fatigueIndicators: { highRPESessions: number, failedSessions: number }

	if (
		fatigueIndicators.highRPESessions > 5 ||
		fatigueIndicators.failedSessions > 3
	) {
		// Apply deload to all exercises
		for (const day of plan.weeklyStructure) {
			for (const exercise of day.exercises) {
				exercise.planned = {
					...exercise.planned,
					sets: Math.max(2, exercise.planned.sets - 1),
					reps: Math.max(5, exercise.planned.reps - 2),
					load_kg: exercise.planned.load_kg
						? exercise.planned.load_kg * 0.8
						: null,
				};
			}
		}

		plan.progressionHistory.push({
			date: formatDateString(new Date()),
			adjustments: [
				{
					exerciseId: null,
					change: "Deload week applied to all exercises",
					reason: "High fatigue indicators detected",
				},
			],
		});

		plan.lastModified = new Date();
		await plan.save();
	}

	return plan;
}

function formatDateString(date) {
	const yyyy = date.getFullYear();
	const mm = String(date.getMonth() + 1).padStart(2, "0");
	const dd = String(date.getDate()).padStart(2, "0");
	return `${yyyy}-${mm}-${dd}`;
}

export {
	analyzePerformance,
	suggestAdjustments,
	autoAdjustPlan,
	handlePlateau,
	deloadIfNeeded,
};
