import AutoGeneratedPlan from "../models/autoGeneratedPlan.model.js";
import Exercise from "../models/exercise.model.js";
import User from "../models/user.model.js";
import UserPlan from "../models/userPlan.model.js";

// Training split templates
const SPLIT_TYPES = {
	FULL_BODY: "full_body",
	UPPER_LOWER: "upper_lower",
	PUSH_PULL_LEGS: "push_pull_legs",
	BODY_PART_SPLIT: "body_part_split",
};

// Goal-based exercise priorities
const GOAL_PRIORITIES = {
	strength: {
		primary: ["squat", "deadlift", "bench", "press"],
		repRange: [3, 6],
		sets: [4, 6],
		focus: "compound",
	},
	muscle_gain: {  // Added alias for hypertrophy
		primary: ["squat", "bench", "row", "press"],
		repRange: [8, 12],
		sets: [3, 4],
		focus: "mixed",
	},
	hypertrophy: {
		primary: ["squat", "bench", "row", "press"],
		repRange: [8, 12],
		sets: [3, 4],
		focus: "mixed",
	},
	fat_loss: {
		primary: ["squat", "deadlift", "lunge", "push-up", "burpee"],
		repRange: [12, 20],
		sets: [3, 5],
		focus: "circuit",
	},
	endurance: {
		primary: ["bodyweight", "cardio"],
		repRange: [15, 20],
		sets: [3, 4],
		focus: "volume",
	},
	general_fitness: {
		primary: ["squat", "push", "pull", "hinge"],
		repRange: [10, 12],
		sets: [3, 4],
		focus: "balanced",
	},
};

// Muscle group mappings (both cases for compatibility)
const MUSCLE_GROUPS = {
	push: ["Chest", "chest", "Shoulders", "shoulders", "Triceps", "triceps"],
	pull: ["Back", "back", "Biceps", "biceps"],
	legs: ["Quadriceps", "quadriceps", "Hamstrings", "hamstrings", "Glutes", "glutes", "Calves", "calves"],
	upper: ["Chest", "chest", "Back", "back", "Shoulders", "shoulders", "Biceps", "biceps", "Triceps", "triceps"],
	lower: ["Quadriceps", "quadriceps", "Hamstrings", "hamstrings", "Glutes", "glutes", "Calves", "calves"],
	core: ["Core", "core", "Abs", "abs", "Obliques", "obliques", "Lower Back", "lower back"],
};

function determineSplitType(daysPerWeek, goals) {
	if (daysPerWeek <= 3) {
		return SPLIT_TYPES.FULL_BODY;
	} else if (daysPerWeek === 4) {
		return SPLIT_TYPES.UPPER_LOWER;
	} else if (daysPerWeek >= 5) {
		if (goals.includes("strength")) {
			return SPLIT_TYPES.UPPER_LOWER; // More frequency for compounds
		}
		return SPLIT_TYPES.PUSH_PULL_LEGS;
	}
	return SPLIT_TYPES.FULL_BODY;
}

function getSplitStructure(splitType, daysPerWeek, preferredDays = []) {
	let structure = [];
	
	switch (splitType) {
		case SPLIT_TYPES.FULL_BODY:
			structure = Array(daysPerWeek)
				.fill(null)
				.map((_, i) => ({
					dayNumber: i + 1,
					name: `Full Body ${i + 1}`,
					focus: "full_body",
				}));
			break;

		case SPLIT_TYPES.UPPER_LOWER:
			const ulPattern = ["upper", "lower", "upper", "lower"];
			structure = ulPattern.slice(0, daysPerWeek).map((focus, i) => ({
				dayNumber: i + 1,
				name: focus === "upper" ? "Upper Body" : "Lower Body",
				focus,
			}));
			break;

		case SPLIT_TYPES.PUSH_PULL_LEGS:
			const pplPattern = ["push", "pull", "legs", "push", "pull", "legs"];
			structure = pplPattern.slice(0, daysPerWeek).map((focus, i) => ({
				dayNumber: i + 1,
				name:
					focus === "push"
						? "Push Day"
						: focus === "pull"
						? "Pull Day"
						: "Leg Day",
				focus,
			}));
			break;

		default:
			structure = [{ dayNumber: 1, name: "Full Body", focus: "full_body" }];
	}

	// Assign preferred days if provided and valid
	if (preferredDays && preferredDays.length >= daysPerWeek) {
		structure = structure.map((day, index) => ({
			...day,
			dayOfWeek: preferredDays[index],
		}));
	}

	return structure;
}

async function selectExercisesForFocus(
	focus,
	equipment,
	experience,
	injuries,
	sessionLength
) {
	// Normalize equipment values to match database (capitalize first letter)
	const normalizedEquipment = equipment.map(e => {
		if (e.toLowerCase() === 'none') return 'None';
		if (e.toLowerCase() === 'bodyweight') return 'Bodyweight';
		// Capitalize first letter for other equipment
		return e.charAt(0).toUpperCase() + e.slice(1).toLowerCase();
	});

	// Build query - if looking for bodyweight/none, also include empty equipment array
	const includesBodyweight = normalizedEquipment.some(e => 
		e === 'Bodyweight' || e === 'None'
	);

	const query = {
		published: true,
		$or: [
			{ equipment: { $in: [...normalizedEquipment, "None", "Bodyweight"] } },
			...(includesBodyweight ? [{ equipment: { $size: 0 } }] : [])
		]
	};

	console.log('Exercise query:', JSON.stringify(query, null, 2));
	console.log('Focus:', focus);
	console.log('Equipment:', equipment);
	console.log('Normalized equipment:', normalizedEquipment);

	// Determine target muscles based on focus
	let targetMuscles = [];
	if (focus === "full_body") {
		targetMuscles = [
			"Chest", "chest",
			"Back", "back",
			"Quadriceps", "quadriceps",
			"Hamstrings", "hamstrings",
			"Shoulders", "shoulders",
			"Core", "core",
			"Glutes", "glutes",
			"Full Body", "full_body",
		];
	} else if (focus === "upper") {
		targetMuscles = MUSCLE_GROUPS.upper;
	} else if (focus === "lower") {
		targetMuscles = MUSCLE_GROUPS.lower;
	} else if (focus === "push") {
		targetMuscles = MUSCLE_GROUPS.push;
	} else if (focus === "pull") {
		targetMuscles = MUSCLE_GROUPS.pull;
	} else if (focus === "legs") {
		targetMuscles = MUSCLE_GROUPS.legs;
	}

	// Filter by target muscles (case-insensitive using regex)
	if (targetMuscles.length > 0) {
		// Use $in with case-insensitive matching
		const muscleRegexes = targetMuscles.map(m => new RegExp(`^${m}$`, 'i'));
		query.primary_muscles = { 
			$in: targetMuscles // Try exact match first (both cases)
		};
	}

	// Exclude exercises that affect injured areas
	if (injuries && injuries.length > 0) {
		const injuryKeywords = injuries.map((i) => i.toLowerCase());
		query.name = {
			$not: { $regex: injuryKeywords.join("|"), $options: "i" },
		};
	}

	const allExercises = await Exercise.find(query).lean();

	console.log('Total exercises found:', allExercises.length);

	// Prioritize compound movements
	const compounds = allExercises.filter((e) =>
		["squat", "deadlift", "bench", "press", "row", "pull"].some((keyword) =>
			e.name.toLowerCase().includes(keyword)
		)
	);

	const isolations = allExercises.filter(
		(e) => !compounds.some((c) => c._id.equals(e._id))
	);

	// Calculate exercise count based on session length and experience
	let exerciseCount = 4;
	if (sessionLength >= 60) exerciseCount = 6;
	if (sessionLength >= 90) exerciseCount = 8;
	if (experience === "beginner") exerciseCount = Math.min(exerciseCount, 5);

	// Select exercises: prioritize compounds, then isolations
	const selected = [];
	const compoundCount = Math.ceil(exerciseCount * 0.6); // 60% compounds

	// Add compounds
	for (let i = 0; i < compoundCount && i < compounds.length; i++) {
		selected.push(compounds[i]);
	}

	// Add isolations
	const remainingCount = exerciseCount - selected.length;
	for (let i = 0; i < remainingCount && i < isolations.length; i++) {
		selected.push(isolations[i]);
	}

	console.log('Selected exercises:', selected.length, '/', exerciseCount);

	return selected;
}

function calculateVolume(experience, goal, exercise) {
	const goalConfig = GOAL_PRIORITIES[goal] || GOAL_PRIORITIES.general_fitness;

	let sets = 3;
	let reps = 10;
	let rest = 90;

	// Adjust based on experience
	if (experience === "beginner") {
		sets = goalConfig.sets[0];
		reps = goalConfig.repRange[0];
		rest = 120;
	} else if (experience === "intermediate") {
		sets = Math.floor((goalConfig.sets[0] + goalConfig.sets[1]) / 2);
		reps = Math.floor((goalConfig.repRange[0] + goalConfig.repRange[1]) / 2);
		rest = 90;
	} else if (experience === "advanced") {
		sets = goalConfig.sets[1];
		reps = goalConfig.repRange[1];
		rest = 60;
	}

	// Check if exercise has default prescription
	const defaultPrescription = {
		sets,
		reps,
		rest_seconds: rest,
	};

	// Use exercise default if available
	if (exercise.default_prescription) {
		return {
			sets: exercise.default_prescription.sets || sets,
			reps: exercise.default_prescription.reps || reps,
			load_kg: exercise.default_prescription.load_kg || null,
			time_seconds: exercise.default_prescription.time_seconds || null,
			rest_seconds: exercise.default_prescription.rest_seconds || rest,
		};
	}

	return defaultPrescription;
}

async function generatePlanForUser(userId, formData = null) {
	// Load user profile
	const user = await User.findById(userId).lean();
	if (!user) {
		throw new Error("User not found");
	}

	const profile = user.profile || {};
	
	// Use form data if provided, otherwise fall back to profile
	const generationParams = formData ? {
		goals: formData.goal && formData.goal !== '' && formData.goal !== 'null' && formData.goal !== null
			? (Array.isArray(formData.goal) ? formData.goal : [formData.goal])
			: ["general_fitness"],
		experience_level: formData.experience_level || "beginner",
		equipment: formData.equipment && formData.equipment.length > 0 
			? formData.equipment 
			: ["bodyweight", "none"],
		days_per_week: formData.days_per_week || 3,
		preferred_days: formData.preferred_days || [],
		session_length_minutes: formData.session_length_minutes || 45,
		injuries: Array.isArray(formData.injuries) 
			? formData.injuries 
			: (formData.injuries && formData.injuries.trim() !== '' ? formData.injuries.split(',').map(i => i.trim()) : []),
		focus_areas: formData.focus_areas || [],
	} : {
		goals: profile.goals && profile.goals.length > 0 ? profile.goals : ["general_fitness"],
		experience_level: profile.experience_level || "beginner",
		equipment: profile.equipment && profile.equipment.length > 0 ? profile.equipment : ["bodyweight", "none"],
		days_per_week: profile.days_per_week || 3,
		preferred_days: profile.preferred_days || [],
		session_length_minutes: profile.session_length_minutes || 45,
		injuries: profile.injuries || [],
		focus_areas: profile.preferences || [],
	};

	console.log('=== GENERATION PARAMS ===');
	console.log('Form Data received:', formData);
	console.log('Form Data goal:', formData?.goal);
	console.log('Generated Params:', generationParams);
	console.log('Final goals array:', generationParams.goals);

	// Update user profile with form data if provided
	if (formData) {
		await User.findByIdAndUpdate(userId, {
			$set: {
				'profile.goals': generationParams.goals,
				'profile.experience_level': generationParams.experience_level,
				'profile.equipment': generationParams.equipment,
				'profile.days_per_week': generationParams.days_per_week,
				'profile.preferred_days': generationParams.preferred_days,
				'profile.session_length_minutes': generationParams.session_length_minutes,
				'profile.injuries': generationParams.injuries,
				'profile.preferences': generationParams.focus_areas,
			}
		});
	}

	// Determine split type
	const splitType = determineSplitType(
		generationParams.days_per_week,
		generationParams.goals
	);
	const splitStructure = getSplitStructure(
		splitType,
		generationParams.days_per_week,
		generationParams.preferred_days
	);

	// Generate exercises for each day
	const primaryGoal = generationParams.goals[0] || "general_fitness";
	const weeklyStructure = [];

	for (const dayTemplate of splitStructure) {
		const exercises = await selectExercisesForFocus(
			dayTemplate.focus,
			generationParams.equipment,
			generationParams.experience_level,
			generationParams.injuries,
			generationParams.session_length_minutes
		);

		console.log(`Day ${dayTemplate.dayNumber} (${dayTemplate.focus}): Found ${exercises.length} exercises`);
		console.log('Equipment filter:', generationParams.equipment);

		const dayExercises = exercises.map((exercise) => {
			const planned = calculateVolume(
				generationParams.experience_level,
				primaryGoal,
				exercise
			);

			return {
				exerciseId: exercise._id,
				planned,
				variant: "base",
				cue: "",
				progression_rule: {
					method: "reps_then_load",
					trigger: "complete_all_sets_twice",
				},
			};
		});

		weeklyStructure.push({
			dayNumber: dayTemplate.dayNumber,
			dayOfWeek: dayTemplate.dayOfWeek,
			name: dayTemplate.name,
			focus: dayTemplate.focus,
			exercises: dayExercises,
		});
	}

	// Deactivate any existing active plans
	await AutoGeneratedPlan.updateMany(
		{ userId, active: true },
		{ $set: { active: false } }
	);

	// Create AutoGeneratedPlan
	const plan = await AutoGeneratedPlan.create({
		userId,
		planType: "auto_generated",
		generationParams,
		weeklyStructure,
		currentWeek: 1,
		progressionHistory: [],
		startedAt: new Date(),
		lastModified: new Date(),
		active: true,
	});

	// Update or create UserPlan
	let userPlan = await UserPlan.findOne({ userId });
	if (userPlan) {
		userPlan.planSource = "auto_generated";
		userPlan.autoGeneratedPlanId = plan._id;
		userPlan.templateId = null;
		userPlan.startedAt = new Date();
		userPlan.currentWeek = 1;
		userPlan.currentDayIndex = 0;
		await userPlan.save();
	} else {
		userPlan = await UserPlan.create({
			userId,
			planSource: "auto_generated",
			autoGeneratedPlanId: plan._id,
			startedAt: new Date(),
		});
	}

	return plan;
}

async function getActivePlanForUser(userId) {
	const plan = await AutoGeneratedPlan.findOne({
		userId,
		active: true,
	}).populate("weeklyStructure.exercises.exerciseId");

	return plan;
}

async function deactivatePlan(planId, userId) {
	const plan = await AutoGeneratedPlan.findOne({ _id: planId, userId });
	if (!plan) {
		throw new Error("Plan not found");
	}

	plan.active = false;
	await plan.save();

	return plan;
}

async function adjustPlan(planId, userId, adjustments) {
	const plan = await AutoGeneratedPlan.findOne({ _id: planId, userId });
	if (!plan) {
		throw new Error("Plan not found");
	}

	// Apply adjustments (e.g., change exercises, modify volume)
	if (adjustments.weeklyStructure) {
		plan.weeklyStructure = adjustments.weeklyStructure;
	}

	plan.lastModified = new Date();
	await plan.save();

	return plan;
}

export {
	generatePlanForUser,
	getActivePlanForUser,
	deactivatePlan,
	adjustPlan,
	determineSplitType,
	selectExercisesForFocus,
	calculateVolume,
};
